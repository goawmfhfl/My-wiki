# 💡웹팩은 무엇일까 ?

> Ajax의 등장

Ajax의 등장에 따라서 페이지에 변경이 되는 부분이 생길 경우에 JavaScript의 요청으로 인하여 서버에서 바뀐 부분에 대한 수정 사항을 받아올 수 있게 되었다. Ajax가 등장함에 따라서 모든 문제가 해결이 된것만 같다. 시간이 지나면서 웹의 수요가 커지고 그에 따라서 작성하는 코드가 많아 지게 되었다. 그럼 그에 따라서 자바스크립트 파일을 늘리면 해결이 될 것 같지만 다른 문제가 발생한다

<br/>

> Ajax 등장과 발생한 문제

Ajax가 생겼다.. 비즈니스가 커질수록 자바스크립트 파일이 많아진다. 여기서 문제는 매번 자바스크립트 파일을 만들 때 마다 데이터 흐름에 맞게 파일의 위치를 선정해 줘야 했다. 또한 모듈화가 되어 있지 않은 자바스크립트는 하나의 전역을 공유하기 때문에 다른 자바스크립트 파일에서 선언한 변수명이 충돌을 할 수 있는 문제가 생길 수 있다. 모듈화가 필요하다.

<br/>

> 잠깐 짚고 넘어가는 Node.js

이전에 자바스크립트는 오로지 브라우저에만 종속된 언어였다. 그렇기에 브라우저에서만 조작이 가능 했지 그 외에 다른 곳에서는 사용을 할 수 없었다.갈수록 웹의 중요성이 커졌다. 온라인으로 비즈니스가 확장이 되기 시작하면서 웹의 기능은 발달하게 되었고 더욱 많은 기능들을 요구하게 되었다. 이런 상황에서 자바스크립트를 범용적으로 사용하자는 말이 나오기 시작했고 대표적인 표준 위원회인 CommonJs, AMD로 인하여 Node.js가 생겨나게 되었다. Node.js로 인해서 자바스크립트로 작성된 코드가 서버에서도 돌아갈 수 있는 환경이 만들어졌다.

<br/>

> 모듈이 태어났다.

Node.js에서는 모듈 기능을 지원하게 되었다. 모듈이 생겨남에 따라서 자바스크립트가 하나의 전역을 공유하는 문제를 해결했다. 이로인해서 변수명이 충돌한다거나 각기 다른 비즈니스 로직의 기능을 담고 있는 자바스크립트 파일이 다른 파일의 비즈니스 로직을 건드려 버그를 발생하는 일이 줄어들게 되었다. 또한 ES6부터는 Node.js 뿐만 아니라 JavaScript 에서도 모듈을 적용시킬 수 있게 되었다. 이로써 문제가 해결이 된 것 같다.

<br/>

> 크로스 브라우징 이슈의 발생

크로스 브라우징 이슈란 무엇인가? 브라우저마다 각기 다른 브라우저 렌더링 엔진을 가지고 있다. 문제는 각 브라우저의 렌더링 엔진이 같은 DOM을 보더라도 해석하는 방식이 다르다는데 있다. 예를들면 크롬에서 돌아가는 기능이 인터넷 익스플로어에서는 돌아가지 않는 것이다 예를들면 HTML Body태그의 주요 태그인 <main>태그가 그러하다. IE에서 Main 태그를 동작시키게 하기 위해서는 CSS 속성으로 display:block을 따로 추가해줘야하는 번거로움이 있다. 이를 하나하나 다 고려해서 코드를 작성하는 일은 매우 번거로운 일이다.

각 브라우저마다 사용하는 렌더링 엔진이다.

- 크롬: 블링크의 소스코드를 가져와 독립적인 새로운 소프트웨어를 개발했는데 그것이 바로 웹킷이다.
- 사파리: 웹킷
- 파이어폭스 : 게코엔진 (Gecko)

그렇다면 이 상황에서 어느정도 크로스 브라우징을 맞췄다고 생각해보자. 여기서 추가로 자바스크립트의 버전이 업그레이드가 된다고 해보자 근데 어떤 브라우저는 자바스크립트의 업그레이드 버전을 반영시켰지만 어떤 브라우저는 자바스립트의 변경 사항을 적용하지 않았다. 이 부분 역시도 문제가된다. 대표적인게 바로 ES6에서 지원하는 기능이 ES5에서 지원하지 않는 것이다. ES6에서는 let, const, class, promise 객체 등 개발자에게 코드의 간결성, 명확성을 선물해주었지만 현실은 es6 를 자유자재로 사용 할 수 없었다. 그 이유는 방금 말한 것 처럼 ie와 같은 구형 브라우저에서는 es6를 제대로 지원하지 않았고 사람들은 구형 브라우저 IE 구형 윈도우 운영체제를 그대로 사용하는 사람들이 많기에 개발하는 입장에서는 es6는 그림의 떡이였다.

<br/>

> 웹팩의 등장

웹팩의 정의를 보자 웹팩은 무슨 뜻일까? 웹팩은 오픈 소스 자바스크립트 모듈 번들러로써 여러개로 나누어져 있는 파일들을 하나의 자바스크립트 코드로 압축하고 최적화하는 라이브러리입니다. 여기서 말하는 번들러는 의존성이 있는 모듈 코드를 하나(또는 여러 개)의 파일로 만들어주는 도구이다. 번들러 중에도 여러 번들러가 있지만 그중에서도 가장 유명한 것은 웹팩이다. webpack은 CommonJS와 AMD 스펙 모두를 지원한다. 하나로 만들어주다니 뭔가 되게 간편해 보인다. 그래서 웹팩이 크로스 브라우징 이슈의 문제를 어떻게 해결했는가 ?

<br/>

> 웹팩의 등장과 크로스 브라우징 이슈 해결

웹팩을 사용하면 자바스크립트 파일들을 웹팩을 통하여 의존성이 있는 모듈 코드 하나(또는 여러개)의 파일로 만들 수 있다고 했다. 웹팩의 구성 요소중 loader를 사용하면 그렇게 모듈화가 되기 전에 약간의 전처리를 할 수 있다. 전처리는 분석하기 좋게 데이터를 고치는 작업을 의미하는데 코드의 변환도 가능하다. 이때 loader중에 바벨 로더라는 것이 있는데 이 `바벨로더`를 사용하면 방금 말했던 Promise를 지원하는 ES6의 문법이 ES5에서도 동작할 수 있도록 도와주며. 이로써 ES6 표준으로 작성되지 않은 라이브러리 역시도 동작을 할 수 있게 도와준다는 점이다. 웹팩을 사용하면 NPM을 통해서 이런 바벨로더 라이브러리를 다운받아 import만 하면 바로 사용을 할 수 있다.

> 이 외의 웹팩 활용의 장점

1. 여러 파일의 자바스크립트 코드를 압축하여 최적화 할 수 있기 때문에 로딩에 대한 네트워크 비용을 줄일 수 있습다
2. 모듈 단위로 개발이 가능하여, 가독성과 유지보수가 쉽다
3. 최신 자바스크립트 문법을 지원하지 않는 브라우저에서 사용할 수 있는 코드로 쉽게 변환시켜 준다

물론, 수 많은 자바스크립트 파일이 하나의 파일로 묶인다면 초기 로딩 속도가 커질 수 있습니다. 하지만 웹팩에서는 청크, 캐시, 코드 스플릿 개념들을 도입하면서 이 문제를 해결하고 있다.

웹팩은 Entry, Output, Loaders, Plugins, Mode로 구성되어있다. 이후는 웹팩의 구성 요소에 대해서 알아보도록 하겠다.

<br/>

# 🔗 Reference

- [https://ljs0705.medium.com/spa-single-page-app-에서-webpack을-사용하는-이유-ce7d3f82fe9](https://ljs0705.medium.com/spa-single-page-app-%EC%97%90%EC%84%9C-webpack%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-ce7d3f82fe9)
- [https://medium.com/@woody_dev/js-webpack-1-웹팩이란-무엇인가-f29ebca31da4](https://medium.com/@woody_dev/js-webpack-1-%EC%9B%B9%ED%8C%A9%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-f29ebca31da4)
- [https://ui.toast.com/fe-guide/ko_BUNDLER](https://ui.toast.com/fe-guide/ko_BUNDLER)
