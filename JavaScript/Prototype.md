# **💡프로토타입**

> **프로토타입이란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다.**

프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티 및 메서드를 제공한다. 프로토타입을 상속받은 하위객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

> **프로토타입의 특징**

- 자바스크립트는 생성자의 prototype 프로퍼티를 통해 타입의 특징을 정의한다.
- 모든 인스턴스는 내부에 `[[prototype]]` 프로퍼티를 가지며 이를 통해 생성자의 prototype 프로퍼티를 추가한다.
- 인스턴스에서 생성자의 `[[prototype]]` 을 타고 올라가며 프로퍼티를 탐색하는 현상을 `프로토타입 체인`이라고한다

# **🚀 예시**

> **프로토타입이란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다.**

- **생성자 함수를 통하여 인스턴스 만들기**

```jsx
function 생성자함수(매개변수) {
  this.매개변수 = 매개변수;
  this.메서드 = function () {
    console.log(this.매개변수 + '는 전달받은 매개변수 입니다.');
  };
}

var 인스턴스1 = new 생성자함수('인스턴스 1에서 보내는 item');
var 인스턴스2 = new 생성자함수('인스턴스 2에서 보내는 item');

console.log(인스턴스1);
// 생성자함수 {매개변수: '인스턴스 1에서 보내는 item', 메서드: ƒ}
console.log(인스턴스2);
// 생성자함수 {매개변수: '인스턴스 2에서 보내는 item', 메서드: ƒ}

console.log(인스턴스1.메서드 === 인스턴스2.메서드); // false
```

인스턴스 1과 인스턴스 2에 만들어진 메서드는 서로 같지 않다 즉, 중복된 동작을 하는 메서드가 2개가 생긴 것이다. 불필요한 함수가 동작하게 만드는 것은 성능 저하를 일으키는 주된 요인이 된다.

> **프로토타입을 통하여 메서드를 생성하기**

```jsx
생성자함수.prototype.일반함수 = function () {
  console.log(this.매개변수 + ' 는 전달받은 매개변수입니다.');
};

function 생성자함수(매개변수) {
  this.매개변수 = 매개변수;
}

var 인스턴스1 = new 생성자함수('인스턴스 1에서 보내는 item');
var 인스턴스2 = new 생성자함수('인스턴스 2에서 보내는 item');

인스턴스1.일반함수();
// 인스턴스 1에서 보내는 item 는 전달받은 매개변수입니다.
인스턴스2.일반함수();
// 인스턴스 2에서 보내는 item 는 전달받은 매개변수입니다.

console.log(인스턴스1.일반함수 === 인스턴스2.일반함수);
```

prototype을 통하여 일반함수를 생성자함수 내부에서 바깥으로 옮겼다. 이때 prototype을 통해서 정의한 일반함수는 생성자함수의 프로토타입이 된다.

> **프로토타입의 특징**
 
<img width="1235" alt="스크린샷 2021-12-13 09 28 48" src="https://user-images.githubusercontent.com/79143800/145737674-8e87f4ae-c14e-4ce1-8826-91580a0de651.png">


자바스크립트의 모든 인스턴스(객체)는 내부에 `[[prototype]]` 이라는 프로퍼티를 가진다.

[[prototype]]을 통해서 부모의 `prototype`에 접근이 가능하다.

인스턴스에서 생성자의 prototype에 접근하기 위하여 프로퍼티를 탐색하는 현상을 `프로토타입 체인`이라고 한다

# **🔗** 참고

- 모던 자바스크립트 DeepDive
