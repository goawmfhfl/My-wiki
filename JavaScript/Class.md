# 💡Class

> 클래스란?

자바스크립트는 생성자 함수라는 템플릿 통하여 속성과 행동을 정의하고 템플릿을 통하여 여러 객체를 생성할 수 있다. 이러한 자바스크립트의 생성자 함수의 특징을 다른 언어의 클래스 문법처럼 바꿔준 것이 바로 클래스다. 클래스는 기존에 있던 생성자 함수와 동작은 일치하다. 한마디로 말해서, 클래스는 생성자 함수를 더 보기 좋고 편리하게 사용할 수 있도록 개선한 문법이다.

이처럼 내부적인 동작은 동일하지만 더 보기 좋고 편리하게 개선된 문법을 `문법적 설탕` 이라고 부른다.

<br/>

> 클래스와 생성자함수의 차이점은?

- 생성자 함수는 메서드가 중복되어 생성되는 것을 방지하기 위해 함수 외부에서 프로토타입을 사용하며 정의해줘야한다. 하지만 클래스는 클래스 함수 내부에서 작성이 가능하다.
- 클래스 내부에서는 strict mode가 자동으로 설정이 되어있다.
- 클래스는 new연산자 없이 호출할 경우 에러가 발생한다.

<br/>

# 🚀 코드예시

- 기존 생성자 함수 방식

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

let travler1 = new 교통정보알리미("서울", "용문", "지하철", "2시간30분");
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

<!--

현재 교통정보알리미의 this는 생성할 인스턴스 즉 travler1을 가리킨다.
travler1에서는 서울,용문,지하철,2시간30분이라는 인수를 전달해서 보낸다.
이때 교통정보알리미의 메서드 예정시간은 prototype을 통해서 교통정보알리미 함수 바깥에서 호출되었다 이는 생성자함수의 상위객체인 prototype에 메서드를 정의하고 인스턴스가 그것을 상속받아서 사용한다. 이로써 모든 객체는 중복되는 메서드를 가질 필요가 없어졌다.

-->

- 클래스 활용

```jsx
class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
let travler1 = new 교통정보알림("서울", "용문", "지하철", "2시간30분");
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

<!--
class에서는 생성자 함수와 다르게 class 내부에 프로토타입을 정의할 수 있다.
생성되는 인스턴스는 함수를 사용하고 싶다면 그저 꺼내와서 사용하면 된다.
클래스를 사용하면 더욱 편리하게 프로토타입을 통한 메서드 상속을 구현할 수 있다.
 -->

- 생성자 함수를 사용한 `생성자 훔치기`

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}

이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
이벤트쿠폰알리미.prototype.예상할인 = function () {
  return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
};

let myInfo = new 이벤트쿠폰알리미(
  "이태원",
  "명동",
  "지하철",
  "예상시간",
  "20분"
);

console.log(myInfo.예정시간());
```

> **_`apply, call`_** **_사용한 생성자 훔치기_**

```jsx
// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}
```

<br/>

call과 apply는 함수를 호출하는 함수이다. 그러나 그냥 실행하는 것이 아니라 첫 번째 인자에 this로 setting하고 싶은 객체를 넘겨주어 this를 바꾸고나서 실행한다. 그런 후에 이벤트 쿠폰 알리미의 속성값들을 배열로 감싼 후에보낸다. `교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);`를 통해서 이벤트 쿠폰 알리미의 속성들을 배열로 담아서 전달한다 그럼 교통정보알리미 함수를 호출할 당시의 this는 이벤트쿠폰알리미이다. 따라서 apply를 통해 전달한 값들을 this에 바인딩한다. 이로써 속성을 중복해서 생성하는것을 방지한다.

> **_`Object.Create`_** **_프로토타입 체인 연결_**

```jsx
이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
```

Object.create 메서드는 지정된 프로토타입 객체 및 속성을 갖는 새 객체를 만든다. 교통정보알리미에 프로토타입 체인을 연결함으로써 하위 클래스는 상위 클래스의 메서드를 상속받을 수 있게 되었다.

```jsx
let myInfo = new 이벤트쿠폰알리미(
  "이태원",
  "명동",
  "지하철",
  "예상시간",
  "20분"
);

console.log(myInfo.예정시간());
console.log(myInfo.예상할인());
```

Object.ctreate를 통해서 프로토타입 체인을 연결하고나면 위와 같이 상위 클래스의 메서드를 하위 클래스의 인스턴스가 사용할 수 있다.

- **_클래스 방식_**

```jsx
// 클래스 교통 정보 알리미

class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
// 클래스 이벤트 쿠폰 알림

class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }

  예상할인() {
    return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
  }
}
let myInfo = new 이벤트쿠폰알림("우리집", "회사", "자차", "2시간");
console.log(myInfo.예정시간()); // 우리집에서 회사까지의 소요 예정 시간은 2시간 입니다
```

> **_`constructor` - 생성자 훔치기_**

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }
```

자식 클래스에 constructor 함수를 선언하면 부모 클래스의 constructor 함수를 덮어쓴다. 이를 해결하기 위해서 super 메서드를 사용해야한다. super 메소드는 슈퍼타입의 생성자를 호출한다.
생성자 함수에서는 apply를 통해서 this값을 새로 바인딩하고 중복되는 속성들에 대한 값들을 배열로 보내어 중복을 방지했다. class에서는 super를 사용해서 extends에 대상이 된 클래스의 속성들을 훔쳐올 수 있다.

> **_`Extends` 상위 클래스의 프로토타입 체인 이어받기_**

기존 방식은 Object.create를 사용해서 프로토타입 체인을 연결해 주었다면 ES6의 클래스 방식에서는 아래와 같은 방법으로 코드를 프로토타입 체인을 연결한다.

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {}
```

`하위 클래스` : 이벤트쿠폰 알림을 `상위 클래스` : 교통정보알림에 연결하는 것이다.

<br/>

> `생성자 함수 vs 클래스`

1. 생성자 훔치기
   클래스를 사용하지 않고 생성자 함수를 사용할 경우에는 부모로부터 속성을 전달받기 위해서는
   call, apply를 통해서 this 바인딩을 변경하여 중복되는 부분을 매개변수로 전달을 해줘야 했다.
   하지만 클래스는 extend를 통해서 확장시킬 클래스를 불러오고 super 메서드를 사용하면 간편하게 생성자 훔치기를 구현할 수 있다.

2. 메서드 상속
   생성자 함수의 매서드 상속은 Object.create를 사용해서 프로토타입 체인을 연결하여 사용한다.
   클래스의 매서드 상속은 Object.create를 사용하지 않아도 extends로 체인을 연결했음으로 따로 코드를 작성하지 않아도 간편하게 상속받아서 사용할 수 있다.

# 🔗 Reference

- [https://wooooooak.github.io/javascript/2018/12/08/call,apply,bind/](https://wooooooak.github.io/javascript/2018/12/08/call,apply,bind/)
