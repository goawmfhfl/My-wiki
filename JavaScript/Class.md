# 💡Class

> **_`클래스는 무엇인가?`_**

클래스는 생성자 함수를 이용하여 인스턴스를 생성하는 방식이 일치한다. 자바스크립트만의 사용자 정의 타입 생성 방법을 다른 언어의 클래스 문법처럼 바꿔준 것이 바로 자바스크립트의 클래스이다. 내부적인 동작은 동일하지만 더 보기 좋고 편리하게 개선된 문법을 `문법적 설탕` 이라고 부른다.

> **_`왜 사용하는가?`_**

extends를 사용하여 상위 타입의 프로토타입을 상속받고 super 메서드를 통해 자식 클래스의 생성자 함수가 부모 클래스의 생성자 함수를 덮어 씌우는 것을 방지할 수 있다. 이런 문법들이 생성자 함수보다 좀 더 편리하며 코드를 직관적으로 작성하는데 도움이 된다고 생각한다.

# 🚀 코드예시

- 기존 생성자 함수 방식

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

let travler1 = new 교통정보알리미('서울', '용문', '지하철', '2시간30분');
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

- 클래스를 활용한 인스턴스 생성 방식

```jsx
class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
let travler1 = new 교통정보알림('서울', '용문', '지하철', '2시간30분');
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

> `***어떤 차이가 있는가?***`

1. 생성자 함수는 외부 클래스는 내부에 메서드를 정의

물론 생성자 함수 역시도 메서드를 정의할 수 있다. 하지만 생성자 함수 내부에 메서드를 정의할 경우 생성된 인스턴스마다 동일한 메서드를 갖게 된다. 그래서 prototype을 통하여 생성자의 constructor 에 직접 메서드를 넣어주었다. 하지만 클래스 안에 생성된 메서드는 중복되어 생성되지 않는다.

1. constructor의 유무

클래스에서는 내부에 constructor라는 함수를 선언하여 인스턴스의 인수를 전달받아 데이터를 바인딩한다. contructor는 인스턴스를 생성하고 초기화하기 위한 특수 메서드다. 클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 이름이 같아 혼동하기 쉽지만 직접적인 관련이 없다. 프로토타입의 construtor 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킨다.

- 생성자 함수 방식

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}

이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
이벤트쿠폰알리미.prototype.예상할인 = function () {
  return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
};

let myInfo = new 이벤트쿠폰알리미(
  '이태원',
  '명동',
  '지하철',
  '예상시간',
  '20분',
);

console.log(myInfo.예정시간());
```

> **_`생성자 훔치기`_**

```jsx
// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}
```

이벤트쿠폰알리미 함수는 교통정보알리미의 프로퍼티를 사용하기 위해서 apply를 통해 this를 간접적으로 정해준 후 인스턴스의 매개변수를 프로퍼티를 전달한다. 이로써 생성된 인스턴스는 중복된 프로퍼티가 생성되는것을 막을 수 있다.

> **_`apply, call`_** **_상위 클래스의 프로토타입 체인 이어받기_**

```jsx
이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
```

Object.create 메서드는 지정된 프로토타입 객체 및 속성을 갖는 새 객체를 만든다. 교통정보알리미에 프로토타입 체인을 연결함으로써 하위 클래스는 상위 클래스의 메서드를 상속받을 수 있게 되었다.

```jsx
let myInfo = new 이벤트쿠폰알리미(
  '이태원',
  '명동',
  '지하철',
  '예상시간',
  '20분',
);

console.log(myInfo.예정시간());
console.log(myInfo.예상할인());
```

Object.ctreate를 통해서 프로토타입 체인을 연결하고나면 위와 같이 상위 클래스의 메서드를 하위 클래스의 인스턴스가 사용할 수 있다.

- **_클래스 방식_**

```jsx
// 클래스 교통 정보 알리미

class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
// 클래스 이벤트 쿠폰 알림

class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }

  예상할인() {
    return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
  }
}
let myInfo = new 이벤트쿠폰알림('우리집', '회사', '자차', '2시간');
// console.log(myInfo.예정시간()); // 우리집에서 회사까지의 소요 예정 시간은 2시간 입니다
```

> **_`constructor` - 생성자 훔치기_**

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }
```

자식 클래스에 constructor 함수를 선언하면 부모 클래스의 constructor 함수를 덮어쓴다. 이를 해결하기 위해서 super 메서드를 사용해야한다. super 메소드는 슈퍼타입의 생성자를 호출한다.

> **_`Extends` 상위 클래스의 프로토타입 체인 이어받기_**

기존 방식은 Object.create를 사용해서 프로토타입 체인을 연결해 주었다면 ES6의 클래스 방식에서는 아래와 같은 방법으로 코드를 프로토타입 체인을 연결한다.

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {}
```

`하위 클래스` : 이벤트쿠폰 알림을 `상위 클래스` : 교통정보알림에 연결하는 것이다.
