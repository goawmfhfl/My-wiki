# 💡Class

> 클래스란?

자바스크립트는 생성자 함수라는 템플릿 통하여 속성과 행동을 정의하고 템플릿을 통하여 여러 객체를 생성할 수 있다. 이러한 자바스크립트의 생성자 함수의 특징을 다른 언어의 클래스 문법처럼 바꿔준 것이 바로 클래스다. 클래스는 기존에 있던 생성자 함수와 동작은 동일하지만 더 보기 좋고 편리하게 사용할 수 있도록 문법을 개선한 것이다

이처럼 내부적인 동작은 동일하지만 더 보기 좋고 편리하게 개선된 문법을 `문법적 설탕` 이라고 부른다.

<br/>

# 🚀 코드예시

- 기존 생성자 함수 방식

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

let travler1 = new 교통정보알리미('서울', '용문', '지하철', '2시간30분');
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

- 클래스 활용

```jsx
class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
let travler1 = new 교통정보알림('서울', '용문', '지하철', '2시간30분');
console.log(travler1.예정시간()); // 서울에서 용문까지의 소요 예정 시간은 2시간30분 입니다
```

- 생성자 함수를 사용한 `생성자 훔치기`

```jsx
function 교통정보알리미(출발지역, 도착지역, 교통, 소요시간) {
  this.출발지역 = 출발지역;
  this.도착지역 = 도착지역;
  this.교통 = 교통;
  this.소요시간 = 소요시간;
}

교통정보알리미.prototype.예정시간 = function () {
  return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
};

// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}

이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
이벤트쿠폰알리미.prototype.예상할인 = function () {
  return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
};

let myInfo = new 이벤트쿠폰알리미(
  '이태원',
  '명동',
  '지하철',
  '예상시간',
  '20분',
);

console.log(myInfo.예정시간());
```

> **_`apply, call`_** **_사용한 생성자 훔치기_**

```jsx
// 이벤트 쿠폰 알리미
function 이벤트쿠폰알리미(출발지역, 도착지역, 교통, 할인, 소요시간) {
  교통정보알리미.apply(this, [출발지역, 도착지역, 교통, 소요시간]);
  this.할인 = 할인;
}
```

이벤트쿠폰알리미 함수는 교통정보알리미의 프로퍼티를 사용하기 위해서 apply를 통해 this를 간접적으로 정해준 후 인스턴스의 매개변수를 프로퍼티를 전달한다. 이로써 생성된 인스턴스는 중복된 프로퍼티가 생성되는것을 막을 수 있다.

> **_`Object.Create`_** **_프로토타입 체인 연결_**

```jsx
이벤트쿠폰알리미.prototype = Object.create(교통정보알리미.prototype);
```

Object.create 메서드는 지정된 프로토타입 객체 및 속성을 갖는 새 객체를 만든다. 교통정보알리미에 프로토타입 체인을 연결함으로써 하위 클래스는 상위 클래스의 메서드를 상속받을 수 있게 되었다.

```jsx
let myInfo = new 이벤트쿠폰알리미(
  '이태원',
  '명동',
  '지하철',
  '예상시간',
  '20분',
);

console.log(myInfo.예정시간());
console.log(myInfo.예상할인());
```

Object.ctreate를 통해서 프로토타입 체인을 연결하고나면 위와 같이 상위 클래스의 메서드를 하위 클래스의 인스턴스가 사용할 수 있다.

- **_클래스 방식_**

```jsx
// 클래스 교통 정보 알리미

class 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간) {
    this.출발지역 = 출발지역;
    this.도착지역 = 도착지역;
    this.교통 = 교통;
    this.소요시간 = 소요시간;
  }
  예정시간() {
    return `${this.출발지역}에서 ${this.도착지역}까지의 소요 예정 시간은 ${this.소요시간} 입니다 `;
  }
}
// 클래스 이벤트 쿠폰 알림

class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }

  예상할인() {
    return `저희 앱을 통해서 ${this.도착지역}에서 ${this.출발지역}까지 ${this.교통}을 통해가시면 ${this.할인}할인 이벤트 쿠폰을 드려요`;
  }
}
let myInfo = new 이벤트쿠폰알림('우리집', '회사', '자차', '2시간');
// console.log(myInfo.예정시간()); // 우리집에서 회사까지의 소요 예정 시간은 2시간 입니다
```

> **_`constructor` - 생성자 훔치기_**

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {
  constructor(출발지역, 도착지역, 교통, 소요시간, 할인) {
    super(출발지역, 도착지역, 교통, 소요시간);
    this.할인 = 할인;
  }
```

자식 클래스에 constructor 함수를 선언하면 부모 클래스의 constructor 함수를 덮어쓴다. 이를 해결하기 위해서 super 메서드를 사용해야한다. super 메소드는 슈퍼타입의 생성자를 호출한다.

> **_`Extends` 상위 클래스의 프로토타입 체인 이어받기_**

기존 방식은 Object.create를 사용해서 프로토타입 체인을 연결해 주었다면 ES6의 클래스 방식에서는 아래와 같은 방법으로 코드를 프로토타입 체인을 연결한다.

```jsx
class 이벤트쿠폰알림 extends 교통정보알림 {}
```

`하위 클래스` : 이벤트쿠폰 알림을 `상위 클래스` : 교통정보알림에 연결하는 것이다.

<br/>

> 생성자 함수와 클래스의 차이점은?

- 생성자 함수는 메서드가 중복되어 생성되는 것을 방지하기 위해 함수 외부에서 프로토타입을 사용하며 정의해줘야한다. 하지만 클래스는 클래스 함수 내부에서 작성이 가능하다.
- 클래스 내부에서는 strict mode가 자동으로 설정이 되어있다.
- 클래스는 new연산자 없이 호출할 경우 에러가 발생한다.
