# 💡 DOM & CSSOM & BOM & Virtual DOM

> DOM이란 무엇인가?

- DOM은 HTML 문서를 브라우저에서 잘 동작할 수 있도록 설계된 객체입니다.
- 만약 브라우저가 공장이라고 가정하면 이때 주문서는 바로 DOM이다. 브라우저는 DOM에 있는 노드들을 실제 제품으로 만들어주는 역할을 하는 것입니다.
- MDN에서는 DOM을 HTML문서를 나타내는 API라고 말한다

<br/>

> DOM의 관점에서 API란 무엇인가

- API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체를 의미한다.
- DOM의 관점에서 바라 본 API란 HTML문서와 브라우저가 서로 상호작용 하는 것을 도와주는 매개체라고 볼 수 있다.

<br/>

> 노드란 무엇인가?

- DOM의 관점에서 노드란 HTML내부의 하나하나의 정보들을 의미한다.
- Node들은 부모 자식 상속관계를 가지고 있어 부모 노드의 속성을 자식 노드에서 상속 받아 사용할 수 있다.

<br/>

> BOM이란 무엇인가?

- BOM은 브라우저 오브젝트 모델을 의미한다.
- 예를들면 alert, navigation, history, documnet 등등이 있다.
- 정확히는 자바스크립트가 아닌 웹 브라우저가 제공하는 기능이다.
- 자바스크립트를 통해서 브라우저의 기능적인 요소들을 직접 제어할 수 있다.

<br/>

> 윈도우 객체란 무엇인가?

- 모든 객체가 소속된 객체이다. 전역 객체이면서, 창이나 프레임을 의미한다. 그렇기에 브라우저의 창 크기 조절, 새 창 열기 등등 브라우저 창의 세부적인 옵션들을 일일이 설정 할 수 있다.
- 자바스크립트의 모든 객체, 전역 함수, 전역 변수들은 자동으로 window 객체의 프로퍼티가 된다.
- DOM의 요소들도 모두 window 객체의 프로퍼티이다.
- let,const 키워드를 생성한 변수는 window의 프로퍼티가 되지 않는다.
- var 키워드를 통해 생성한 변수는 window의 프로퍼티가 된다.

<br/>

> CSSOM이란 무엇인가

- CSSOM은 스타일과 관련된 노드들이 모여서 형성된 객체 형태이다.
- CSSOM은 브라우저 렌더링 과정에서 스타일과 관련된 link태그를 만나 생성되기 시작한다
- DOM이 완성이 된 이후 CSSOM이 결합되어 화면에 보여질 요소들만 걸러진 후에 Render Tree로 그려진다.

<br/>

> 가상 DOM은 왜 생겼는가?

예전의 Single Page Application의 동작 방식에서는 페이지에 변경사항이 일어날 경우에 Ajax 비동기 요청을 하여 변경사항을 하나하나 예측하여 수정해줬다. 이렇게 코드를 수정하는 일은 많은 작업시간을 소요하는 일이다. 또한 페이지에 대한 잦은 변경으로 인하여 변경된 부분에 대한 레이아웃 재생성 과정인 reflow reapint가 자주 발생하게 되었다. 리액트는 이러한 문제를 해결하기 위해서 가상 DOM이라는 개념을 만들었다. 가상 DOM은 실제 돔의 복사본을 만들어 변경된 부분만 효율적으로 변경이 가능할 수 있게 설계했다. 이로인해 reflow, repaint는 단 한번만 이루어 지게되었으며, 변경 사항에 대한 코드를 예측하여 일일이 작성할 필요도 없어졌다.

<br/>

> 가상 DOM은 무엇인가?

실제 돔과 다른 가상의 돔으로 실제 돔의 복사본이라고 이해하면 좋다. 가상돔은 메모리상에만 존재하며 실제 화면에는 나타나지 않는 복사본과 같다. 가상돔은 실제 돔에서 변경이 일어날 경우 변경사항을 Diffing 알고리즘을 통하여 분석한다. 변경된 부분을 파악하면 변경된 부분에 대한 업데이트를 진행한다

<br/>

> 가상 돔의 동작 원리에 대해서 설명해달라

기존 브라우저 렌더링의 순서에 따르면 자바스크립트로 DOM의 요소가 변경이 될 때마다 매번 리플로우 리페인트가 발생하여 성능 저하의 주된 요인이 되었다. 리액트의 버추어 돔은 특정 부분이 리렌더링 되어야 할 때 그 부분에 해당하는 virtual DOM 트리를 메모리에 새로 생성하고 diffing 알고리즘으로 비교하여 차이점을 파악한다 그리고 그 차이점들을 하나로 모아서 virtual DOM을 하나로 모아서 실제 DOM에게 전달해준다. 이로 인해서 실제 DOM의 리렌더링 연산은 단 한번만 일어나게 되어 큰 성능의 이득을 얻게 된다.

<br/>

> 가상 돔이 쓰이는 진짜 이유

DOM 조작의 실제 문제는 각 조작이 레이아웃 변화, 트리 변화와 렌더링을 일으킨다는겁니다. 그래서, 예를 들어 여러분이 30개의 노드를 하나 하나 수정하면, 그 뜻은 30번의 (잠재적인) 레이아웃 재계산과 30번의 (잠재적인) 리렌더링을 초래한다는 것이죠. Virtual DOM 은 그냥 뭐 엄청 새로운것도 아니고, 그냥 DOM 차원에서의 더블 버퍼링이랑 다름이 없는거에요. 변화가 일어나면 그걸 오프라인 DOM 트리에 적용시키죠. 이 DOM 트리는 렌더링도 되지 않기때문에 연산 비용이 적어요. 연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 던져주는거에요. 딱 한번만 한는거에요.

모든 변화를 하나로 묶어서. 그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만, 다시 한번 강조하자면 딱 한번만 하는거에요. 바로 이렇게, 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄이는거구요.

사실, 이 과정은 Virtual DOM 이 없이도 이뤄질수 있어요. 그냥, 변화가 있을 때, 그 변화를 묶어서 DOM fragment 에 적용한 다음에 기존 DOM 에 던져주면 돼요.

그러면, Virtual DOM 이 해결 하려고 하는건 무엇이냐? `DOM fragment를 관리하는 과정을 수동으로 하나하나 작업 할 필요 없이, 자동화하고 추상화하는거에요.` 그 뿐만 아니라, 만약에 이 작업을 여러분들이 직접 한다면, 기존 값 중 어떤게 바뀌었고 어떤게 바뀌지 않았는지 계속 파악하고 있어야하는데 (그렇지 않으면 수정 할 필요가 없는 DOM 트리도 업데이트를 하게 될 수도 있으니까요), 이것도 Virtual DOM 이 이걸 자동으로 해주는거에요. 어떤게 바뀌었는지 , 어떤게 바뀌지 않았는지 알아내주죠.

마지막으로, DOM 관리를 Virtual DOM 이 하도록 함으로써, 컴포넌트가 DOM 조작 요청을 할 때 다른 컴포넌트들과 상호작용을 하지 않아도 되고, 특정 DOM 을 조작할 것 이라던지, 이미 조작했다던지에 대한 정보를 공유 할 필요가 없습니다. 즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다는거죠.

# 🔗 Reference

- [https://it-eldorado.tistory.com/87](https://it-eldorado.tistory.com/87)
- [https://www.youtube.com/watch?v=1ojA5mLWts8](https://www.youtube.com/watch?v=1ojA5mLWts8)
- [https://velopert.com/3236](https://velopert.com/3236)
- [https://wickies.tistory.com/26](https://wickies.tistory.com/26)
- [http://www.tcpschool.com/javascript/js_bom_window](http://www.tcpschool.com/javascript/js_bom_window)
- [https://basemenks.tistory.com/24](https://basemenks.tistory.com/24)
